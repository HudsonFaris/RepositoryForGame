I, Sam Bangapadang, certify that I participated equitably in the creation of assignment C17A-2, dated 3/11/2024.
I, Hudson Faris, certify that I participated equitably in the creation of assignment C17A-2, dated 3/11/2024.


commit 2260a4c7c336b1b9676d315af2d9f59453001073
Author: HudsonFaris <118467880+HudsonFaris@users.noreply.github.com>
Date:   Mon Mar 11 21:03:52 2024 -0600

    Reduced redundencies in if statements and changed calcTargets so another method was easier to follow

commit 0bfdf03e02b82d2398e2ecacdebbcb8a654c673d
Author: HudsonFaris <118467880+HudsonFaris@users.noreply.github.com>
Date:   Mon Mar 11 21:00:33 2024 -0600

    Fixed Board class, reduced lines and removed repeat getters/setters

commit c3e1cc398f55e693fdc97633e02f4a7fffa502ea
Author: HudsonFaris <118467880+HudsonFaris@users.noreply.github.com>
Date:   Mon Mar 11 20:53:09 2024 -0600

    Made getAdjList more dry, easier to follow and sig reduced lines

commit acef39d13f70150e4c81e5c69205782c216c2e06
Author: HudsonFaris <118467880+HudsonFaris@users.noreply.github.com>
Date:   Mon Mar 11 20:51:17 2024 -0600

    Made calcTargets function easier to read and follow

commit 75970daf0f18a2d17f12b28c95f8940e4746f2c4
Author: HudsonFaris <118467880+HudsonFaris@users.noreply.github.com>
Date:   Mon Mar 11 20:48:21 2024 -0600

    Made layout config more method seperable and easier to read

commit c094529a9189dc77bdd9f8bb3c883d02f36998bf
Author: HudsonFaris <118467880+HudsonFaris@users.noreply.github.com>
Date:   Mon Mar 11 20:46:06 2024 -0600

    Made creating boardCell signifigantly easier to read

commit 6c97552ef047fb55001e6b6f78e0141dea316e52
Author: HudsonFaris <118467880+HudsonFaris@users.noreply.github.com>
Date:   Mon Mar 11 20:43:48 2024 -0600

    Fixed spacing issues for braces
    
commit 0a734cc6bede28900fe298c4760e9fa5eb5a9136
Author sbangapadang22 <<51834910+sbangapadang22@users.noreply.github.com>
Date: Mon Mar 11 19:24:49 2024 -0600

	Any other changes

commit 0a734cdhawhd28900fe298c4760e9fa5eb5a9136
Author sbangapadang22 <<51834910+sbangapadang22@users.noreply.github.com>
Date: Mon Mar 11 18:59:49 2024 -0600

	Went through and changed indentation as needed
	
commit leud0310fe298c4760e9fa5eb5a9136
Author sbangapadang22 <<51834910+sbangapadang22@users.noreply.github.com>
Date: Mon Mar 11 17:04:32 2024 -0600

	Broke down calcAdj into smaller methods for readability/simplicity

commit 0a734cc65ede28900fe298c4760e623a5eb5a9136
Author sbangapadang22 <<51834910+sbangapadang22@users.noreply.github.com>
Date: Mon Mar 11 17:02:15 2024 -0600

	Added roomhelpers to simplify roomCenter calculations
	
commit 0a5193cc6bede28900fe298c4760e9fa5eb5a9136
Author sbangapadang22 <<51834910+sbangapadang22@users.noreply.github.com>
Date: Mon Mar 11 16:50:20 2024 -0600

	Added default property for clarity




Most significant change: calculateAdj();
/**
     * Calculates adjacent targets for path == 0. Acts as helper function to method above. 
     */
    private void calculateAdj() {
        for (int row = 0; row < getNumRows(); row++) {
            for (int col = 0; col < getNumColumns(); col++) {
                BoardCell cell = getCellAt(row, col);
                // Check if the cell is not null before proceeding
                if (cell != null) {
                	if ((row > 0)) {
                	    BoardCell adjacentCell = getCellAt(row-1, col);
                	    if (adjacentCell != null && !adjacentCell.isRoom() && adjacentCell.getInitial() != 'X') {  // Check that the adjacent cell is not null
                	    	cell.addAdj(adjacentCell);
                	    }
                	}
                	if ((row < getNumRows()-1)) {
                	    BoardCell adjacentCell = getCellAt(row+1, col);
                	    if (adjacentCell != null  && !adjacentCell.isRoom()&& adjacentCell.getInitial() != 'X') {  // Check that the adjacent cell is not null
                	    	cell.addAdj(adjacentCell);
                	    }
                	}
                	
                	if (col > 0) {
                	    BoardCell adjacentCell = getCellAt(row, col - 1);
                	    if (adjacentCell != null && !adjacentCell.isRoom()&& adjacentCell.getInitial() != 'X') { // Check if the cell is not null
                	    	cell.addAdj(adjacentCell);
                	    }
                	}

                	if (col < getNumColumns() - 1) {
                	    BoardCell adjacentCell = getCellAt(row, col + 1);
                	    if (adjacentCell != null && !adjacentCell.isRoom()&& adjacentCell.getInitial() != 'X') { // Check if the cell is not null
                	    	cell.addAdj(adjacentCell);
                	    }
                	}
                	
                	
                	
                	
                	   
                    // If the cell is a room center, check the whole board for doors pointing to it
                	if (cell.isRoomCenter()) {
                	    char roomInitial = cell.getInitial();
                	    for (int doorRow = 0; doorRow < getNumRows(); doorRow++) {
                	        for (int doorCol = 0; doorCol < getNumColumns(); doorCol++) {
                	            BoardCell potentialDoorCell = getCellAt(doorRow, doorCol);
                	            if (potentialDoorCell.isDoorway()) {
                	                DoorDirection direction = potentialDoorCell.getDoorDirection();
                	                BoardCell adjacentCell = null;

                	                switch (direction) {
                	                    case UP:
                	                        if (doorRow > 0) {
                	                            adjacentCell = getCellAt(doorRow - 1, doorCol);
                	                        }
                	                        break;
                	                    case DOWN:
                	                        if (doorRow < getNumRows() - 1) {
                	                            adjacentCell = getCellAt(doorRow + 1, doorCol);
                	                        }
                	                        break;
                	                    case RIGHT:
                	                        if (doorCol < getNumColumns() - 1) {
                	                            adjacentCell = getCellAt(doorRow, doorCol + 1);
                	                        }
                	                        break;
                	                    case LEFT:
                	                        if (doorCol > 0) {
                	                            adjacentCell = getCellAt(doorRow, doorCol - 1);
                	                        }
                	                        break;
                	                }

                	                if (adjacentCell != null && adjacentCell.getInitial() == roomInitial) {
                	                    cell.addAdj(potentialDoorCell);  // Add the doorway as adjacent
                	                  
                	                }
                	                
                	            }
                	        
                	    
                	
                            }
                        }
                    }
                    
                    }
                if (cell.isSecretPassage()) {
            		BoardCell origCell = findRoomCenterByInitial(cell.getInitial());
                    char secretPassageInitial = cell.getSecretPassage(); 
                    if (secretPassageInitial != '0') { // Check if the initial is valid
                        BoardCell secretPassageTarget = findRoomCenterByInitial(secretPassageInitial);
                        if (secretPassageTarget != null) {
                            origCell.addAdj(secretPassageTarget); // Add the center of the target room as adjacent
                            
                        }
                    }
                }
                    
                if (cell != null && cell.isDoorway()) {        
                    DoorDirection direction = cell.getDoorDirection();
                    char initial;

                    if (direction == DoorDirection.UP && row > 0) {
                        initial = getCellAt(row-1, col).getInitial();
                    } else if (direction == DoorDirection.DOWN && row < getNumRows() - 1) {
                        initial = getCellAt(row+1, col).getInitial();
                    } else if (direction == DoorDirection.RIGHT && col < getNumColumns() - 1) {
                        initial = getCellAt(row, col+1).getInitial();
                    } else if (direction == DoorDirection.LEFT && col > 0) {
                        initial = getCellAt(row, col-1).getInitial();
                    } else {
                        continue;  // Skip to the next iteration if none of the conditions are met
                    }

                    BoardCell newCell = findRoomCenterByInitial(initial);
                    if (newCell != null) {
                        cell.addAdj(newCell);
                    }
                }
                
            }
            }
        
        }


Changed to:
// Calculates adjacencies for all cells, applying game-specific rules for movement, doorways, and secret passages.
    private void calculateAdj() {
        // Iterate through each cell on the board.
        for (int row = 0; row < getNumRows(); row++) {
            for (int col = 0; col < getNumColumns(); col++) {
                BoardCell cell = getCellAt(row, col); // Retrieve the current cell.
                if (cell != null) { // Ensure the cell exists.
                    // Add adjacent cells based on the current cell's properties.
                    addAdjacentCells(cell, row, col);
                    if (cell.isRoomCenter()) {
                        // If the cell is a room center, add doorways leading into the room as adjacencies.
                        addDoorwaysAsAdjacencies(cell, row, col);
                    }
                    if (cell.isSecretPassage()) {
                        // If the cell has a secret passage, add the corresponding room center as an adjacency.
                        addSecretPassageAdjacency(cell);
                    }
                    if (cell.isDoorway()) {
                        // If the cell is a doorway, add the adjacent room center or hallway cell as an adjacency.
                        addRoomCenterAdjacencyForDoorway(cell, row, col);
                    }
                }
            }
        }
    }

    /**
     * Adds adjacent cells to the specified cell considering the game rules.
     * This includes checking for valid adjacent cells in all four cardinal directions
     * and excluding cells that are part of a room or marked as impassable ('X').
     */
    private void addAdjacentCells(BoardCell cell, int row, int col) {
        // Directions to check for adjacency: Up, Down, Left, Right
        int[] rowOffsets = {-1, 1, 0, 0};
        int[] colOffsets = {0, 0, -1, 1};
        for (int i = 0; i < rowOffsets.length; i++) {
            int adjRow = row + rowOffsets[i];
            int adjCol = col + colOffsets[i];
            // Check if the cell is within the board boundaries and has valid characteristics
            if (isValidCell(adjRow, adjCol)) {
                BoardCell adjacentCell = getCellAt(adjRow, adjCol);
                // Add the cell to adjacencies if it's not part of a room or impassable
                if (adjacentCell != null && !adjacentCell.isRoom() && adjacentCell.getInitial() != 'X') {
                    cell.addAdj(adjacentCell);
                }
            }
        }
    }

    /**
     * Identifies and adds doorway cells leading into a room center to the room center's adjacency list.
     * This is used to connect doorways directly to room centers for gameplay mechanics, allowing players
     * to move through doorways into rooms efficiently.
     */
    private void addDoorwaysAsAdjacencies(BoardCell cell, int row, int col) {
        // Iterate over the entire board to find doorways that lead into the specified room
        for (int doorRow = 0; doorRow < getNumRows(); doorRow++) {
            for (int doorCol = 0; doorCol < getNumColumns(); doorCol++) {
                BoardCell potentialDoorCell = getCellAt(doorRow, doorCol);
                // Add the doorway as an adjacency if it leads directly into the room
                if (potentialDoorCell != null && potentialDoorCell.isDoorway() && isDoorwayPointingToRoom(potentialDoorCell, cell.getInitial())) {
                    cell.addAdj(potentialDoorCell);
                }
            }
        }
    }

    /**
     * Adds an adjacency link between a cell containing a secret passage and the center of the target room.
     * This allows for direct movement between distant rooms via the secret passage, a key gameplay feature.
     */
    private void addSecretPassageAdjacency(BoardCell cell) {
        // Check if there's a valid secret passage and link it to the target room center
        if (cell.getSecretPassage() != '0') { // '0' indicates no secret passage
            BoardCell secretPassageTarget = findRoomCenterByInitial(cell.getSecretPassage());
            if (secretPassageTarget != null) {
                cell.addAdj(secretPassageTarget);
            }
        }
    }

    /**
     * For doorway cells, adds an adjacency to the corresponding room center or next cell in the hallway,
     * allowing for movement through the doorway into the room or continuing in the hallway.
     */
    private void addRoomCenterAdjacencyForDoorway(BoardCell cell, int row, int col) {
        // Determine the cell that the doorway leads to based on its direction
        BoardCell targetCell = getTargetCellForDoorway(cell, cell.getDoorDirection(), row, col);
        if (targetCell != null) {
            // Add the target cell as an adjacency to facilitate movement through the doorway
            cell.addAdj(targetCell);
        }
    }

    /**
     * Checks if a given row and column index correspond to a valid cell on the board.
     * This is used to prevent out-of-bounds access when calculating adjacencies.
     */
    private boolean isValidCell(int row, int col) {
        return row >= 0 && row < getNumRows() && col >= 0 && col < getNumColumns();
    }

    /**
     * Determines if a doorway cell is correctly positioned to lead into a specified room,
     * based on the room's initial character and the doorway's direction.
     */
    private boolean isDoorwayPointingToRoom(BoardCell doorCell, char roomInitial) {
        BoardCell adjacentCell = getTargetCellForDoorway(doorCell, doorCell.getDoorDirection(), doorCell.getRow(), doorCell.getCol());
        // Check if the adjacent cell matches the specified room initial
        return adjacentCell != null && adjacentCell.getInitial() == roomInitial;
    }

    /**
     * Calculates the cell a doorway leads to, based on the door's direction.
     * This supports movement through doorways by identifying the adjacent cell in the direction the door faces.
     */
    private BoardCell getTargetCellForDoorway(BoardCell cell, DoorDirection direction, int row, int col) {
        switch (direction) {
            case UP: return isValidCell(row - 1, col) ? getCellAt(row - 1, col) : null;
            case DOWN: return isValidCell(row + 1, col) ? getCellAt(row + 1, col) : null;
            case RIGHT: return isValidCell(row, col + 1) ? getCellAt(row, col + 1) : null;
            case LEFT: return isValidCell(row, col - 1) ? getCellAt(row, col - 1) : null;
            default: return null; // In case of an invalid direction
        }
    }

